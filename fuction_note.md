
# Python 学习笔记：函数参数魔法与递归思维

> 整理自廖雪峰 Python 教程。涵盖了参数解包、尾递归原理及汉诺塔经典算法。

## 第一部分：函数参数的进阶机制

### 1. 默认参数的“深坑” (CS 面试必考)
Python 的默认参数在函数定义时就被计算并创建了。
* **原则**：默认参数必须指向**不可变对象** (None, str, tuple, int)。
* **禁忌**：绝对不要用 List 或 Dict 做默认参数。

**❌ 错误写法：**
```python
def add_end(L=[]): # L 指向了一个固定的内存地址
    L.append('END')
    return L
# 第一次调用返回 ['END']
# 第二次调用返回 ['END', 'END'] -> 逻辑炸裂
````

**✅ 正确写法：**

```python
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
```

### 2\. 万能参数：`*args` 和 `**kw`

Python 允许函数接收任意数量的参数，这是通过“打包”和“解包”实现的。

  * **`*args` (可变参数)**：
      * 接收一堆位置参数，打包成一个 **Tuple (元组)**。
      * 场景：`sum(1, 2, 3)` -\> `args = (1, 2, 3)`
  * **`**kw` (关键字参数)**：
      * 接收一堆键值对参数，打包成一个 **Dict (字典)**。
      * 场景：`func(city='Beijing', job='Coder')` -\> `kw = {'city': 'Beijing', ...}`

### 3\. 参数解包 (Argument Unpacking)

这是 Python 最强大的特性之一。我们可以把 List/Tuple/Dict 拆散了传给函数。

```python
def f(a, b, c):
    print(a, b, c)

args = [1, 2, 3]
f(*args) # 等同于 f(1, 2, 3) -> 输出 1 2 3
```

### 4\. 参数定义的“黄金顺序”

如果你要把所有类型的参数混着用，必须严格遵守以下顺序：

1.  必选参数 (Position)
2.  默认参数 (Default)
3.  可变参数 (`*args`)
4.  命名关键字参数 (Keyword-only)
5.  关键字参数 (`**kw`)

-----

## 第二部分：递归与尾递归

### 1\. 递归的本质 (Stack Frame)

普通递归（如 `return n * fact(n-1)`）每深入一层，都需要在内存栈中保留当前的计算状态（等着下一层算出结果传回来再乘）。

  * **风险**：层数太深会导致 **Stack Overflow (栈溢出)**。

### 2\. 尾递归 (Tail Recursion)

  * **定义**：函数的最后一步仅仅是调用函数本身，**没有任何其他的运算**。
  * **目的**：通过参数（比如 `product`）把状态传给下一层，理论上可以复用栈帧，节省内存。

<!-- end list -->

```python
def fact_iter(num, product):
    if num == 1:
        return product
    # return 后面只有函数调用，没有 num * ...
    return fact_iter(num - 1, num * product) 
```

  * **注意**：Python 标准解释器**没有**做尾递归优化，所以写成这样依然会溢出，但理解这个思想对学习算法（和函数式编程）非常重要。

-----

## 第三部分：经典实战——汉诺塔 (Hanoi Tower)

### 代码实现

将 n 个盘子从 A 借助 B 移动到 C。

```python
def move(n, a, b, c):
    # 1. 基准情况 (Base Case)：只剩一个盘子，直接移
    if n == 1:
        print(a, '-->', c)
    # 2. 递归步骤 (Recursive Step)
    else:
        # 第一步：把上面的 n-1 个盘子，从 A 搬到 B (C 做中转)
        move(n - 1, a, c, b)
        
        # 第二步：把最底下的 1 个大盘子，从 A 搬到 C
        print(a, '-->', c)
        
        # 第三步：把 B 上的 n-1 个盘子，搬到 C (A 做中转)
        move(n - 1, b, a, c)
```

-----

## 第四部分：如何培养递归思维 (CS 进阶心法)

初学者写递归觉得难，是因为人脑习惯了“一步步走”的**过程式思维**（循环），而递归需要**宏观定义的思维**（数学归纳法）。

### 1\. 相信你的函数 (The Leap of Faith)

当你写 `move(n-1, a, c, b)` 时，**不要试图去人脑模拟**那 n-1 个盘子具体是怎么一步步移的。你会把自己绕晕。

**思维转换**：

  * 假设 `move` 函数已经是完美的，它一定能把 n-1 个盘子移过去。
  * 把 n-1 个盘子看作一个整体（一块“大奥利奥”）。
  * 现在的任务仅仅是：移走奥利奥 -\> 移底座 -\> 移回奥利奥。

### 2\. 寻找“基准情况” (Base Case)

递归必须有终点，否则就是死循环。

  * 问自己：**问题的最小规模是什么？**
  * 汉诺塔里，最小规模就是 `n=1`。这时候不需要策略，直接动手搬。

### 3\. 定义清楚“做什么”，而不是“怎么做”

  * **循环思维 (Imperative)**：先拿第1个，再拿第2个，判断一下……
  * **递归思维 (Declarative)**：
      * 我要算 `fact(n)`，只要我知道 `fact(n-1)` 就行了。
      * 我要移 `n` 个盘子，只要有人帮我搞定 `n-1` 个就行了。
